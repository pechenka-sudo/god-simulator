<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Симулятор Бога — Three.js</title>
<style>
  body { margin:0; overflow:hidden; background:#000; font-family:Arial; }
  #info { position:absolute; top:10px; left:10px; color:white; background:rgba(0,0,0,0.6); padding:10px; border-radius:10px; pointer-events:none; z-index:100; }
  canvas { display:block; }
</style>
<script src="https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.167.1/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>
<div id="info">
Симулятор Бога<br>
Кликни по экрану → WASD + мышь<br>
ЛКМ — поставить ▪ ПКМ — сломать ▪ Колёсико — блок<br>
G полёт ▪ L молния ▪ M метеорит ▪ F наводнение ▪ V вулкан<br>
Z зомби ▪ H огонь ▪ J золото ▪ I поднять остров ▪ X АПОКАЛИПСИС
</div>
<script>
// Основные объекты
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 10, 200);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.PointerLockControls(camera, document.body);
document.body.addEventListener('click', () => controls.lock());

camera.position.set(0, 10, 20);

// Свет
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(50, 100, 50);
scene.add(sun);

// Блоки
const blockSize = 1;
const blocks = {};
const textures = {
  grass: 0x00ff00, dirt: 0x8b4513, stone: 0xaaaaaa,
  water: 0x0088ff, lava: 0xff4400, gold: 0xffd700
};
const blockTypes = ['grass','dirt','stone','water','lava','gold'];
let currentBlock = 0;

// Создание блока
function addBlock(x, y, z, type = blockTypes[currentBlock]) {
  const key = `${x}_${y}_${z}`;
  if (blocks[key]) return;
  const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
  const material = new THREE.MeshLambertMaterial({
    color: textures[type],
    transparent: type==='water',
    opacity: type==='water' ? 0.6 : 1
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
  scene.add(mesh);
  blocks[key] = mesh;
}

// Удаление блока
function removeBlock(mesh) {
  const pos = mesh.position;
  const key = `${Math.floor(pos.x-0.5)}_${Math.floor(pos.y-0.5)}_${Math.floor(pos.z-0.5)}`;
  scene.remove(mesh);
  delete blocks[key];
}

// Генерация начального мира
for (let x = -30; x < 30; x++) {
  for (let z = -30; z < 30; z++) {
    const height = Math.floor(Math.sin(x*0.1)*Math.cos(z*0.1)*4 + 8);
    for (let y = 0; y < height; y++) {
      let type = 'stone';
      if (y >= height-4) type = 'dirt';
      if (y === height-1) type = height > 3 ? 'grass' : 'sand';
      addBlock(x, y, z, type);
    }
  }
}

// Луч для кликов
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2(0, 0);

// Управление
const keys = {};
onkeydown = onkeyup = e => keys[e.key.toLowerCase()] = e.type === 'keydown';

onwheel = e => {
  currentBlock = (currentBlock + (e.deltaY > 0 ? 1 : -1) + blockTypes.length) % blockTypes.length;
  info.innerHTML = info.innerHTML.replace(/Блок: .+/, `Блок: ${blockTypes[currentBlock].toUpperCase()}`);
};

onmousedown = e => {
  if (!controls.isLocked) return;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(scene.children);
  if (intersects.length === 0) return;
  const hit = intersects[0];
  if (e.button === 0) { // ЛКМ
    const p = hit.point.clone().add(hit.face.normal.multiplyScalar(0.5));
    addBlock(Math.floor(p.x), Math.floor(p.y), Math.floor(p.z));
  } else if (e.button === 2) { // ПКМ
    removeBlock(hit.object);
  }
};
oncontextmenu = e => e.preventDefault();

// Божественные силы
function lightning() {
  const pos = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(40));
  pos.y += 20;
  const bolt = new THREE.Mesh(new THREE.BoxGeometry(0.4,50,0.4), new THREE.MeshBasicMaterial({color:0xffff00}));
  bolt.position.copy(pos);
  scene.add(bolt);
  setTimeout(() => scene.remove(bolt), 300);
}

function meteor() {
  const m = new THREE.Mesh(new THREE.SphereGeometry(4), new THREE.MeshBasicMaterial({color:0xff5500}));
  m.position.set(camera.position.x + Math.random()*100-50, 80, camera.position.z + Math.random()*100-50);
  scene.add(m);
  const fall = setInterval(() => {
    m.position.y -= 3;
    if (m.position.y < 0) { scene.remove(m); clearInterval(fall); }
  }, 30);
}

function flood() {
  for (let i = 0; i < 200; i++) {
    addBlock(camera.position.x + Math.random()*60-30, 3, camera.position.z + Math.random()*60-30, 'water');
  }
}

function volcano() {
  const px = camera.position.x, pz = camera.position.z;
  for (let r = 5; r < 25; r += 3) {
    for (let a = 0; a < 360; a += 20) {
      const rad = a * Math.PI / 180;
      addBlock(px + Math.cos(rad)*r, 15 + Math.random()*15, pz + Math.sin(rad)*r, 'lava');
    }
  }
}

function zombies() {
  for (let i = 0; i < 20; i++) {
    const z = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), new THREE.MeshBasicMaterial({color:0x006600}));
    z.position.set(camera.position.x + Math.random()*80-40, 10, camera.position.z + Math.random()*80-40);
    scene.add(z);
    // простое преследование
    const chase = setInterval(() => {
      const dir = camera.position.clone().sub(z.position).normalize();
      z.position.add(dir.multiplyScalar(0.1));
      if (z.position.distanceTo(camera.position) > 150) { scene.remove(z); clearInterval(chase); }
    }, 50);
  }
}

// Анимация
function animate() {
  requestAnimationFrame(animate);
  
  if (controls.isLocked) {
    const speed = keys['shift'] ? 0.5 : 0.2;
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);
    const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0,1,0)).normalize();
    
    if (keys['w']) camera.position.addScaledVector(direction, speed);
    if (keys['s']) camera.position.addScaledVector(direction, -speed);
    if (keys['a']) camera.position.addScaledVector(right, -speed);
    if (keys['d']) camera.position.addScaledVector(right, speed);
    if (keys[' '] || keys['g']) camera.position.y += speed * 2;
    if (keys['c']) camera.position.y -= speed * 2;

    // Силы по клавишам
    if (keys['l']) { lightning(); keys['l']=false; }
    if (keys['m']) { meteor(); keys['m']=false; }
    if (keys['f']) { flood(); keys['f']=false; }
    if (keys['v']) { volcano(); keys['v']=false; }
    if (keys['z']) { zombies(); keys['z']=false; }
    if (keys['x']) { lightning(); meteor(); flood(); volcano(); zombies(); keys['x']=false; }
  }
  
  renderer.render(scene, camera);
}
animate();

window.onresize = () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
};
</script>
</body>
</html>
